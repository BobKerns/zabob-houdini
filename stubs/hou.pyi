"""
Houdini hou module stubs for development.
This provides comprehensive type hints for the hou module when developing outside Houdini.
Hand-maintained for zabob-houdini project.

These stubs are designed to handle common type issues with Houdini's C++ bindings:
- Clear static vs instance method distinctions
- Comprehensive return type annotations
- Proper null handling and optional types
- Parameter type unions for flexible input acceptance
- Dynamic attribute access patterns
"""

from tkinter import N
from typing import Any, Sequence, Iterable, TypeAlias, overload, Type, TypeVar, Callable
from collections.abc import Iterator
import sys

from hrecipes.api.networkitems import SubnetIndirectInput

# Type variables for generic operations
T = TypeVar('T')
NodeT = TypeVar('NodeT', bound='Node')

# Common type unions that Houdini uses (modern types)
ParameterValue = int | float | str | bool
ParameterDict = dict[str, ParameterValue]
NodePath = str | 'Node'
TransformValue = float | Sequence[float]

_Floats2: TypeAlias = 'tuple[float, float]|Sequence[float]|Vector2'  # A sequence of floats representing a point (x, y)

_Floats3: TypeAlias = 'tuple[float, float, float]|Sequence[float]|Vector3'

class EnumValue:
    """A simple class to represent enum values in Houdini."""
    def name(self) -> str: ...

class NetworkItemType:
    """Enum for Houdini network item types."""
    Connection: 'EnumValue'
    NetworkBox: 'EnumValue'
    NetworkDot: 'EnumValue'
    Node: 'EnumValue'
    StickyNote: 'EnumValue'
    SubnetIndirectInput: 'EnumValue'


class BoundingRect:
    """Houdini bounding rectangle object."""
    @overload
    def __init__(self, x1: float, y1: float, x2: float, y2: float) -> None: ...
    @overload
    def __init__(self, p1: 'Vector2', p2: 'Vector2') -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def setTo(self, bounds_sequence: Sequence[float]) -> None: ...
    def isValid(self) -> bool: ...
    def isAlmostEqual(self, rect: 'BoundingRect', tolerance: float = 0.00001) -> bool: ...
    def min(self) -> 'Vector2': ...
    def max(self) -> 'Vector2': ...
    def size(self) -> 'Vector3': ...
    def center(self) -> 'Vector3': ...
    def contains(self, point: 'Vector2|BoundingRect') -> bool: ...
    def isEmpty(self) -> bool: ...
    @overload
    def intersects(self, other: 'NetworkMovableItem') -> bool: ...
    @overload
    def intersects(self, p1: _Floats2, p2: _Floats2) -> bool: ...
    @overload
    def intersects(self, p1: _Floats2, p2: _Floats2, p3: _Floats2) -> bool: ...
    def intersects(self, *args, **kwargs) -> bool: ...
    def closestPoint(self, point: '_Floats2') -> 'Vector2': ...
    def getOffsetToAvoid(self, bounds: 'BoundingRect', direction: 'Vector2|None' = None) -> 'Vector2': ...
    def translate(self, offset: '_Floats2') -> None: ...
    def scale(self, scale: _Floats2) -> None: ...
    def expand(self, offset: '_Floats2') -> None: ...
    def enlargeToContain(self, point_or_rect: '_Floats2|BoundingRect') -> None: ...
    def intersect(self, rect: 'BoundingRect') -> None: ...

class NetworkItem:
    """Base class for items that can be part of a network layout."""
    def networkItemType(self) -> 'NetworkItemType': ...

class NetworkMovableItem(NetworkItem):
    """Interface for items that can be moved in a network layout."""
    # Name and path
    def name(self) -> str: ...
    def setName(self, name: str) -> None: ...
    def digitsInName(self) -> int: ...
    def path(self) -> str: ...
    def relativePathTo(self, other: 'NetworkMovableItem') -> str: ...

    # Hierarchy
    def parent(self) -> 'NetworkMovableItem|None': ...
    def parentNetworkBox(self) -> 'NetworkBox|None': ...

    # Selection
    def isSelected(self) -> bool: ...
    def isPicked(self) -> bool: ...
    def setSelected(self, on: bool, clear_all_selected: bool=False, show_asset_if_selected: bool=False) -> None: ...
    def color(self) -> 'Color': ...
    def setColor(self, color: 'Color') -> None: ...
    def sessionId(self) -> int: ...

    # Layout
    def position(self) -> 'Vector2': ...
    def setPosition(self, position: '_Floats2') -> None: ...
    def move(self, vector2: '_Floats2') -> None: ...
    def shiftPosition(self, vector2: '_Floats2') -> None: ...
    def size(self) -> 'Vector2': ...

class NetworkBox(NetworkMovableItem):
    '''
    A network box
    '''
    def addItem(self, item: NetworkMovableItem) -> None: ...
    def addNetworkBox(self, name: str) -> 'NetworkBox': ...
    def addNode(self, node_type: str, name: str|None = None) -> 'Node': ...
    def alpha(self) -> float: ...
    def asCode(self, brief: bool=False, recurse: bool=False, save_box_contents: bool=False, save_channels_only: bool=False, save_creation_command: bool=False, save_keys_in_frames: bool=False, save_parm_values_only: bool=False, save_spare_parms: bool=False, save_box_membership: bool=True, function_name: str|None=None) -> str: ...
    def autoFit(self) -> bool: ...
    def comment(self) -> str: ...
    def destroy(self, destroy_contents: bool) -> None: ...
    def fitAroundContents(self) -> None: ...
    def isMinimized(self) -> bool: ...
    def items(self) -> tuple[NetworkMovableItem, ...]: ...
    def minimizedSize(self) -> 'Vector2': ...
    def nodes(self, recurse: bool=True) -> tuple['Node', ...]: ...
    def networkBoxes(self, recurse: bool=True) -> tuple['NetworkBox', ...]: ...
    def removeAllItems(self) -> None: ...
    def removeItem(self, item: NetworkMovableItem) -> None: ...
    def resize(self, vector2: Vector2) -> None: ...
    def restoredSize(self) -> 'Vector2': ...
    def setAutoFit(self, on: bool) -> None: ...
    def setBounds(self, bounds: BoundingRect) -> None: ...
    def setComment(self, comment: str) -> None: ...
    def setMinimized(self, on: bool) -> None: ...
    def setAlpha(self, alpha: float) -> None: ...
    def setSize(self, size: '_Floats2') -> None: ...
    def stickyNotes(self, recurse: bool=True) -> tuple['StickyNote', ...]: ...


class StickyNote(NetworkMovableItem):
    """A sticky note in the network editor."""
    def text(self) -> str: ...
    def setText(self, text: str) -> None: ...
    def textColor(self) -> 'Color': ...
    def setColor(self, color: 'Color') -> None: ...
    def textSize(self) -> float: ...
    def setTextSize(self, size: float) -> None: ...
    def destroy(self) -> None: ...
    def drawBackground(self) -> bool: ...
    def isMinimized(self) -> bool: ...
    def maximizedSize(self) -> 'Vector2': ...
    def resize(self, vector2: _Floats2) -> None: ...
    def restoredSize(self) -> 'Vector2': ...
    def setBounds(self, bounds: BoundingRect) -> None: ...
    def setMinimized(self, on: bool) -> None: ...
    def setDrawBackground(self, on: bool) -> None: ...
    def asData(self) -> dict[str, Any]: ...
    def setFromData(self, data: dict[str, Any]) -> None: ...


class Node(NetworkMovableItem):
    """
    Houdini node object.

    Note: This class handles the complex type patterns in Houdini's C++ bindings
    where methods can return None unexpectedly and parameters accept multiple types.
    """
    def __init__(self) -> None: ...

    # Basic node info - these are generally reliable
    def type(self) -> 'NodeType': ...  # Can raise OperationFailed if node is invalid
    def children(self) -> tuple['Node', ...]: ...  # Empty tuple if no children

    # Parameters - handle Houdini's flexible parameter system
    def parm(self, name: str) -> 'Parm|None': ...  # None if parameter doesn't exist
    def parms(self) -> tuple['Parm', ...]: ...  # All parameters, never None
    def parmTuple(self, name: str) -> 'ParmTuple|None': ...  # None if not a tuple parm
    def parmTuples(self) -> tuple['ParmTuple', ...]: ...  # All tuple parms, never None

    # Enhanced parameter setting with better type handling
    def setParms(self, parm_dict: ParameterDict) -> None: ...  # Can raise OperationFailed
    def setParmValues(self, parm_dict: dict[str, Any]) -> None: ...  # Alternative form

    # Parameter evaluation - handle different return types
    def evalParm(self, name: str) -> ParameterValue: ...  # Returns int, float, str, or bool
    def evalParmTuple(self, name: str) -> tuple[float, ...]: ...  # Always floats for tuples    # Type-specific parameter evaluation methods (more reliable than overloads)
    def evalParmAsFloat(self, name: str) -> float: ...
    def evalParmAsInt(self, name: str) -> int: ...
    def evalParmAsString(self, name: str) -> str: ...

    # Node connections - handle Houdini's sparse input patterns
    def inputs(self) -> tuple['Node|None', ...]: ...  # None for unconnected inputs
    def outputs(self) -> tuple['Node', ...]: ...  # Connected outputs only
    def setInput(self, input_index: int, node: 'Node|None', output_index: int = 0) -> None: ...
    def inputConnections(self) -> tuple['NodeConnection', ...]: ...  # Only connected inputs
    def outputConnections(self) -> tuple['NodeConnection', ...]: ...  # All output connections

    # Input/output info
    def inputIndex(self, node: 'Node') -> int: ...  # -1 if not connected
    def outputIndex(self, node: 'Node') -> int: ...  # -1 if not connected
    def connectedInput(self, index: int) -> 'Node|None': ...  # None if unconnected
    def connectedInputs(self) -> list['Node|None']: ...  # List with None for gaps    # Node creation and management - handle creation failures gracefully
    def createNode(self, node_type: str, name: str|None = None) -> 'Node': ...  # Can raise OperationFailed
    def node(self, path: str) -> 'Node|None': ...  # None if path doesn't exist
    def glob(self, pattern: str) -> tuple['Node', ...]: ...  # Empty if no matches
    def destroy(self) -> None: ...  # Can raise OperationFailed if locked/referenced
    def canCreateNode(self, node_type: str) -> bool: ...  # Safe check before creation

    # Enhanced node queries with better error handling
    def findNode(self, path: str, create_if_needed: bool = False) -> 'Node|None': ...
    def allSubChildren(self,
                      filter_type: str|None = None,
                      recurse_in_locked: bool = False) -> tuple['Node', ...]: ...

    # Node state
    def isLocked(self) -> bool: ...
    def setLocked(self, locked: bool) -> None: ...
    def isBypassed(self) -> bool: ...
    def setBypassed(self, bypassed: bool) -> None: ...
    def isDisplayFlagSet(self) -> bool: ...
    def setDisplayFlag(self, on: bool) -> None: ...
    def isRenderFlagSet(self) -> bool: ...
    def setRenderFlag(self, on: bool) -> None: ...
    def isTemplateFlagSet(self) -> bool: ...
    def setTemplateFlag(self, on: bool) -> None: ...

    # Cooking and dependencies
    def cook(self, force: bool = False) -> None: ...
    def isDependentOn(self, node: 'Node') -> bool: ...
    def dependents(self) -> tuple['Node', ...]: ...
    def dependencies(self) -> tuple['Node', ...]: ...

    # Node context helpers
    def childTypeCategory(self) -> 'NodeTypeCategory': ...
    def allowedChildTypes(self) -> tuple['NodeType', ...]: ...

    # Layout
    def moveToGoodPosition(self, relative_to_inputs: bool=True, move_inputs: bool=True, move_outputs: bool=True, move_unconnected: bool=True) -> 'Vector2': ...
    def layoutChildren(self, items: tuple['NetworkMovableItem', ...]=(), horizontal_spacing=-1.0, vertical_spacing=-1.0) -> 'Vector2': ...

class Parm:
    """Houdini parameter object."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def eval(self) -> Any: ...
    def evalAsFloat(self) -> float: ...
    def evalAsInt(self) -> int: ...
    def evalAsString(self) -> str: ...
    def set(self, value: Any) -> None: ...
    def setExpression(self, expression: str) -> None: ...
    def expression(self) -> str: ...
    def unexpandedString(self) -> str: ...
    def node(self) -> 'Node': ...
    def parmTemplate(self) -> 'ParmTemplate': ...
    def isLocked(self) -> bool: ...
    def lock(self, on: bool) -> None: ...

class ParmTuple:
    """Houdini parameter tuple object (for vector parameters)."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def eval(self) -> tuple[float, ...]: ...
    def evalAsFloats(self) -> tuple[float, ...]: ...
    def evalAsInts(self) -> tuple[int, ...]: ...
    def evalAsStrings(self) -> tuple[str, ...]: ...
    def set(self, values: Sequence[Any]) -> None: ...
    def setExpression(self, expressions: Sequence[str]) -> None: ...
    def node(self) -> 'Node': ...
    def parmTemplate(self) -> 'ParmTemplate': ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> 'Parm': ...

class NodeConnection:
    """Houdini node connection object."""
    def __init__(self) -> None: ...
    def inputNode(self) -> 'Node': ...
    def outputNode(self) -> 'Node': ...
    def inputIndex(self) -> int: ...
    def outputIndex(self) -> int: ...

class NodeType:
    """Houdini node type object."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def description(self) -> str: ...
    def helpUrl(self) -> str: ...
    def category(self) -> 'NodeTypeCategory': ...
    def defaultName(self) -> str: ...
    def maxNumInputs(self) -> int: ...
    def minNumInputs(self) -> int: ...
    def maxNumOutputs(self) -> int: ...
    def childTypeCategory(self) -> 'NodeTypeCategory': ...
    def isGenerator(self) -> bool: ...
    def isManager(self) -> bool: ...
    def embeddedHelp(self) -> str: ...
    def defaultColor(self) -> 'Color': ...
    def setDefaultColor(self, color: 'Color') -> None: ...
    def defaultShape(self) -> str: ...
    def setDefaultShape(self, shape: str) -> None: ...
    def isWritable(self) -> bool: ...
    def isReadOnly(self) -> bool: ...
    def icon(self) -> str: ...
    def resolvedIcon(self) -> str: ...
    def hasUnorderedInputs(self) -> bool: ...
    def hasEditableInputData(self) -> bool: ...
    def parmTemplates(self) -> tuple['ParmTemplate', ...]: ...
    def parmTemplateGroup(self) -> 'ParmTemplateGroup': ...
    def deprecationInfo(self) -> dict[str, Any]: ...

class ParmTemplateGroup:
    """Houdini parameter template group object."""
    def __init__(self, parm_templates: Sequence[ParmTemplate]=()) -> None: ...
    def name(self) -> str: ...
    def label(self) -> str: ...
    def setName(self, name: str) -> None: ...
    def setLabel(self, label: str) -> None: ...
    def clear(self) -> None: ...
    def entries(self) -> tuple['ParmTemplate', ...]: ...
    def parmTemplates(self) -> tuple['ParmTemplate', ...]: ...
    def find(self, name: str) -> 'ParmTemplate|None': ...
    def findFolder(self, label_or_labels: str | Sequence[str]) -> 'ParmTemplateGroup|None': ...
    def findIndices(self, label_or_labels: str | Sequence[str]) -> int | tuple[int, ...]: ...
    def entryAtIndices(self, indices: int | Sequence[int]) -> 'ParmTemplate': ...
    def asCode(self, function_name: str | None=None, variable_name: str | None=None) -> str: ...
    # Additional methods for adding and removing parms

class NodeTypeCategory:
    """Houdini node type category object."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def description(self) -> str: ...
    def nodeTypes(self) -> dict[str, 'NodeType']: ...
    def nodeType(self, name: str) -> 'NodeType|None': ...
    def label(self) -> str: ...
    def allowedChildTypes(self) -> tuple['NodeType', ...]: ...
    def canContainNodeType(self, node_type: 'NodeType') -> bool: ...
    def hasSubNetworkType(self) -> bool: ...
    def subnetworkType(self) -> 'NodeType|None': ...
    def defaultColor(self) -> 'Color': ...


class Color:
    """Houdini color object."""
    def __init__(self, rgb: tuple) -> None: ...
    def rgb(self) -> tuple[float, float, float]: ...
    def setRgb(self, rgb: tuple[float, float, float]) -> None: ...
    def hsv(self) -> tuple[float, float, float]: ...
    def setHsv(self, hsv: tuple[float, float, float]) -> None: ...
    def hsl(self) -> tuple[float, float, float]: ...
    def setHsl(self, hsl: tuple[float, float, float]) -> None: ...
    def lab(self) -> tuple[float, float, float]: ...
    def setLAB(self, lab: tuple[float, float, float]) -> None: ...
    def tmi(self) -> tuple[float, float, float]: ...
    def setTmi(self, tmi: tuple[float, float, float]) -> None: ...
    def xyz(self) -> tuple[float, float, float]: ...
    def setXYZ(self, xyz: tuple[float, float, float]) -> None: ...
    def ocio_transform(self, from_space: str, to_space: str, looks: str) -> 'Color': ...
    def ocio_viewTransform(self, src_colorspace, display_name, view_name) -> 'Color': ...
    @staticmethod
    def reload_ocio() -> None: ...
    @staticmethod
    def ocio_spaces() -> tuple[str, ...]: ...
    @staticmethod
    def ocio_configPath() -> str: ...
    @staticmethod
    def ocio_activeDisplays() -> tuple[str, ...]: ...
    @staticmethod
    def ocio_activeViews() -> tuple[str, ...]: ...
    @staticmethod
    def ocio_looks() -> tuple[str, ...]: ...
    @staticmethod
    def ocio_roles() -> tuple[str, ...]: ...
    @staticmethod
    def ocio_views() -> tuple[str, ...]: ...
    @staticmethod
    def ocio_DefaultView() -> str: ...
    @staticmethod
    def ocio_DefaultDisplay() -> str: ...

class ParmTemplate:
    """Houdini parameter template object."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def label(self) -> str: ...
    def type(self) -> 'ParmTemplateType': ...
    def numComponents(self) -> int: ...
    def defaultValue(self) -> Any: ...
    def help(self) -> str: ...
    def tags(self) -> dict[str, str]: ...
    def setTags(self, tags: dict[str, str]) -> None: ...
    def scriptCallback(self) -> str: ...
    def setScriptCallback(self, callback: str) -> None: ...
    def scriptCallbackLanguage(self) -> str: ...
    def setScriptCallbackLanguage(self, language: str) -> None: ...

class ParmTemplateType:
    """Houdini parameter template type enum-like object."""
    pass

class SopNode(Node):
    """
    Houdini geometry (SOP) node.
    Handles geometry operations and cooking properly.
    """
    def geometry(self) -> 'Geometry': ...  # None if not cooked or failed
    def cook(self, force: bool = False) -> None: ...  # Can raise cooking errors
    def renderGeometry(self) -> 'Geometry': ...  # Rendered geometry
    def displayGeometry(self) -> 'Geometry': ...  # Display geometry

    # SOP-specific parameter access
    def geometryType(self) -> str: ...  # "polygon", "nurbs", etc.
    def isGeometryReadOnly(self) -> bool: ...

class ObjNode(Node):
    """
    Houdini object (OBJ) node.
    Handles transforms and object-level operations.
    """
    def worldTransform(self) -> 'Matrix4': ...  # Can be expensive, may fail
    def localTransform(self) -> 'Matrix4': ...  # Local transformation
    def worldTransformAtTime(self, time: float) -> 'Matrix4': ...
    def localTransformAtTime(self, time: float) -> 'Matrix4': ...

    # Object-specific operations
    def isDisplayFlagSet(self) -> bool: ...  # Override with OBJ-specific behavior
    def isSelectableFlagSet(self) -> bool: ...
    def setSelectableFlag(self, on: bool) -> None: ...

class ChopNode(Node):
    """Houdini channel operator (CHOP) node."""
    def tracks(self) -> tuple['Track', ...]: ...
    def track(self, name: str) -> 'Track|None': ...

class RopNode(Node):
    """Houdini render operator (ROP) node."""
    def render(self, frame_range: tuple[int, int]|None = None,
               background: bool = False) -> None: ...  # Can take a long timeclass VopNode(Node):
    """Houdini VEX operator (VOP) node."""
    def vexCode(self) -> str: ...  # Generated VEX code
    def shaderName(self) -> str: ...

class DopNode(Node):
    """Houdini dynamics operator (DOP) node."""
    def simulation(self) -> 'DopSimulation|None': ...

# Additional specialized node types
class CopNode(Node):
    """Houdini compositing operator (COP) node."""
    def image(self) -> 'Image|None': ...

class TopNode(Node):
    """Houdini task operator (TOP/PDG) node."""
    def workItems(self) -> tuple['WorkItem', ...]: ...

class Geometry:
    """Houdini geometry object."""
    def __init__(self) -> None: ...
    def points(self) -> tuple['Point', ...]: ...
    def prims(self) -> tuple['Prim', ...]: ...
    def vertices(self) -> tuple['Vertex', ...]: ...
    def numPoints(self) -> int: ...
    def numPrims(self) -> int: ...

class Point:
    """Houdini geometry point."""
    def __init__(self) -> None: ...
    def number(self) -> int: ...
    def position(self) -> 'Vector3': ...
    def setPosition(self, pos: 'Vector3') -> None: ...

class Prim:
    """Houdini geometry primitive."""
    def __init__(self) -> None: ...
    def number(self) -> int: ...
    def vertices(self) -> tuple['Vertex', ...]: ...

class Vertex:
    """Houdini geometry vertex."""
    def __init__(self) -> None: ...
    def number(self) -> int: ...
    def point(self) -> 'Point': ...

class Vector2:
    """2D vector."""
    def __init__(self, x: float = 0, y: float = 0) -> None: ...
    def x(self) -> float: ...
    def y(self) -> float: ...

class Vector3:
    """3D vector."""
    def __init__(self, x: float = 0, y: float = 0, z: float = 0) -> None: ...
    def x(self) -> float: ...
    def y(self) -> float: ...
    def z(self) -> float: ...

class Matrix4:
    """4x4 transformation matrix."""
    def __init__(self) -> None: ...

# Module-level functions - these are the PRIMARY module interface
# Note: These handle the static/instance confusion by being clearly module-level

def node(path: str) -> Node:
    """
    Get node by path. Returns None if path doesn't exist.
    This is the main way to access existing nodes.
    """
    ...

def root() -> Node:
    """Get root node. Always succeeds."""
    ...

def pwd() -> Node:
    """Get current working directory node. Always succeeds."""
    ...

def cd(path: str) -> None:
    """
    Change current directory. Can raise OperationFailed if path invalid.
    Affects behavior of relative paths in other hou functions.
    """
    ...

def selectedNodes() -> tuple[Node, ...]:
    """Get currently selected nodes. Empty tuple if none selected."""
    ...

def clearAllSelected() -> None:
    """Clear all node selections. Always succeeds."""
    ...

# Enhanced node finding with better error handling
def findNode(path: str) -> Node:
    """Find node by path, returns None if not found (alias for node())."""
    ...

def nodeAtPath(path: str, create_missing_dirs: bool = False) -> Node:
    """
    Get node at path, optionally creating parent directories.
    More robust than basic node() function.
    """
    ...

# Node type functions
def nodeTypeCategories() -> dict[str, NodeTypeCategory]:
    """Get all node type categories."""
    ...

def nodeType(category: str | NodeTypeCategory, name: str) -> NodeType|None:
    """Get a specific node type."""
    ...

# Session info
def applicationName() -> str:
    """Get application name."""
    ...

def applicationVersion() -> tuple[int, int, int]:
    """Get application version as tuple."""
    ...

def applicationVersionString() -> str:
    """Get application version as string."""
    ...

def isUIAvailable() -> bool:
    """Check if UI is available."""
    ...

class HipFile:
    """Houdini hip file operations."""
    def name(self) -> str: ...
    def path(self) -> str: ...
    def save(self, file_name: str|None = None) -> None: ...
    def load(self, file_name: str) -> None: ...
    def clear(self) -> None: ...
    def isNewFile(self) -> bool: ...

# File operations - hipFile is both a function and an instance in Houdini
hipFile: HipFile

# Common exceptions that Houdini can raise
class OperationFailed(Exception):
    """Houdini operation failed exception."""
    pass

class InvalidInput(Exception):
    """Invalid input exception."""
    pass

class LoadWarning(Warning):
    """Houdini load warning."""
    pass

# Additional specialized classes for different node types
class Track:
    """CHOP track (channel) object."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def samples(self) -> tuple[float, ...]: ...
    def values(self) -> tuple[float, ...]: ...

class DopSimulation:
    """DOP simulation object."""
    def __init__(self) -> None: ...
    def objects(self) -> tuple['DopObject', ...]: ...
    def timestep(self) -> float: ...

class DopObject:
    """DOP simulation object."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def geometry(self) -> 'Geometry|None': ...

class Image:
    """COP image object."""
    def __init__(self) -> None: ...
    def resolution(self) -> tuple[int, int]: ...
    def pixels(self) -> Any: ...  # NumPy array if available

class WorkItem:
    """TOP/PDG work item."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def state(self) -> str: ...  # "ready", "cooking", "cooked", "failed"

# Context managers for safer Houdini operations
class UndoGroup:
    """Context manager for grouping operations into a single undo."""
    def __init__(self, name: str) -> None: ...
    def __enter__(self) -> 'UndoGroup': ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...

def undos() -> 'UndoManager':
    """Get undo manager for grouping operations."""
    ...

class UndoManager:
    """Undo manager for grouping operations."""
    def group(self, name: str) -> UndoGroup: ...
    def clear(self) -> None: ...
    def disabler(self) -> 'UndoDisabler': ...

class UndoDisabler:
    """Context manager to disable undo tracking."""
    def __enter__(self) -> 'UndoDisabler': ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...

# Progress reporting for long operations
def progressBar() -> 'ProgressBar':
    """Get progress bar for long operations."""
    ...

class ProgressBar:
    """Progress reporting for long operations."""
    def __init__(self) -> None: ...
    def __enter__(self) -> 'ProgressBar': ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
    def update(self, progress: float, message: str = "") -> None: ...
    def setLabel(self, label: str) -> None: ...
