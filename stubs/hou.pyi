"""
Houdini hou module stubs for development.
This provides comprehensive type hints for the hou module when developing outside Houdini.
Hand-maintained for zabob-houdini project.

These stubs are designed to handle common type issues with Houdini's C++ bindings:
- Clear static vs instance method distinctions
- Comprehensive return type annotations
- Proper null handling and optional types
- Parameter type unions for flexible input acceptance
- Dynamic attribute access patterns
"""

from ast import expr
from re import L
from tkinter import N
from typing import Any, Generic, Sequence, Iterable, TypeAlias, overload, Type, TypeVar, Callable
from collections.abc import Iterator
import types
import sys

from hrecipes.api.networkitems import SubnetIndirectInput
from searchbox.radialmenus import RadialMenus

# Type variables for generic operations
T = TypeVar('T')
NodeT = TypeVar('NodeT', bound='Node')

# Common type unions that Houdini uses (modern types)
ParameterValue = int | float | str | bool
ParameterDict = dict[str, ParameterValue]
NodePath = str | 'Node'
TransformValue = float | Sequence[float]

_Floats2: TypeAlias = 'tuple[float, float]|Sequence[float]|Vector2'  # A sequence of floats representing a point (x, y)

_Floats3: TypeAlias = 'tuple[float, float, float]|Sequence[float]|Vector3'

class EnumValue:
    """A simple class to represent enum values in Houdini."""
    def name(self) -> str: ...


class _Enum:
    pass

E = TypeVar('E', bound=_Enum)
class _EnumValue(EnumValue, Generic[E]):
    pass

class networkItemType(_Enum):
    """Enum for Houdini network item types."""
    Connection: '_EnumValue[networkItemType]'
    NetworkBox: '_EnumValue[networkItemType]'
    NetworkDot: '_EnumValue[networkItemType]'
    Node: '_EnumValue[networkItemType]'
    StickyNote: '_EnumValue[networkItemType]'
    SubnetIndirectInput: '_EnumValue[networkItemType]'

class exprLanguage(_Enum):
    """Enum for Houdini expression languages."""
    Python: '_EnumValue[exprLanguage]'
    Hscript: '_EnumValue[exprLanguage]'

class parmTemplateType(_Enum):
    """Houdini parameter template type enum-like object."""
    Int: '_EnumValue[parmTemplateType]'
    Float: '_EnumValue[parmTemplateType]'
    String: '_EnumValue[parmTemplateType]'
    Toggle: '_EnumValue[parmTemplateType]'
    Button: '_EnumValue[parmTemplateType]'
    Menu: '_EnumValue[parmTemplateType]'
    FolderSet: '_EnumValue[parmTemplateType]'
    Folder: '_EnumValue[parmTemplateType]'
    Separator: '_EnumValue[parmTemplateType]'
    Label: '_EnumValue[parmTemplateType]'
    Ramp: '_EnumValue[parmTemplateType]'
    Data: '_EnumValue[parmTemplateType]'

class BoundingRect:
    """Houdini bounding rectangle object."""
    @overload
    def __init__(self, x1: float, y1: float, x2: float, y2: float) -> None: ...
    @overload
    def __init__(self, p1: 'Vector2', p2: 'Vector2') -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def setTo(self, bounds_sequence: Sequence[float]) -> None: ...
    def isValid(self) -> bool: ...
    def isAlmostEqual(self, rect: 'BoundingRect', tolerance: float = 0.00001) -> bool: ...
    def min(self) -> 'Vector2': ...
    def max(self) -> 'Vector2': ...
    def size(self) -> 'Vector3': ...
    def center(self) -> 'Vector3': ...
    def contains(self, point: 'Vector2|BoundingRect') -> bool: ...
    def isEmpty(self) -> bool: ...
    @overload
    def intersects(self, other: 'NetworkMovableItem') -> bool: ...
    @overload
    def intersects(self, p1: _Floats2, p2: _Floats2) -> bool: ...
    @overload
    def intersects(self, p1: _Floats2, p2: _Floats2, p3: _Floats2) -> bool: ...
    def intersects(self, *args, **kwargs) -> bool: ...
    def closestPoint(self, point: '_Floats2') -> 'Vector2': ...
    def getOffsetToAvoid(self, bounds: 'BoundingRect', direction: 'Vector2|None' = None) -> 'Vector2': ...
    def translate(self, offset: '_Floats2') -> None: ...
    def scale(self, scale: _Floats2) -> None: ...
    def expand(self, offset: '_Floats2') -> None: ...
    def enlargeToContain(self, point_or_rect: '_Floats2|BoundingRect') -> None: ...
    def intersect(self, rect: 'BoundingRect') -> None: ...

class NetworkItem:
    """Base class for items that can be part of a network layout."""
    def networkItemType(self) -> 'networkItemType': ...

class NetworkMovableItem(NetworkItem):
    """Interface for items that can be moved in a network layout."""
    # Name and path
    def name(self) -> str: ...
    def setName(self, name: str) -> None: ...
    def digitsInName(self) -> int: ...
    def path(self) -> str: ...
    def relativePathTo(self, other: 'NetworkMovableItem') -> str: ...

    # Hierarchy
    def parent(self) -> 'NetworkMovableItem|None': ...
    def parentNetworkBox(self) -> 'NetworkBox|None': ...

    # Selection
    def isSelected(self) -> bool: ...
    def isPicked(self) -> bool: ...
    def setSelected(self, on: bool, clear_all_selected: bool=False, show_asset_if_selected: bool=False) -> None: ...
    def color(self) -> 'Color': ...
    def setColor(self, color: 'Color') -> None: ...
    def sessionId(self) -> int: ...

    # Layout
    def position(self) -> 'Vector2': ...
    def setPosition(self, position: '_Floats2') -> None: ...
    def move(self, vector2: '_Floats2') -> None: ...
    def shiftPosition(self, vector2: '_Floats2') -> None: ...
    def size(self) -> 'Vector2': ...

class NetworkBox(NetworkMovableItem):
    '''
    A network box
    '''
    def addItem(self, item: NetworkMovableItem) -> None: ...
    def addNetworkBox(self, name: str) -> 'NetworkBox': ...
    def addNode(self, node_type: str, name: str|None = None) -> 'Node': ...
    def alpha(self) -> float: ...
    def asCode(self, brief: bool=False, recurse: bool=False, save_box_contents: bool=False, save_channels_only: bool=False, save_creation_command: bool=False, save_keys_in_frames: bool=False, save_parm_values_only: bool=False, save_spare_parms: bool=False, save_box_membership: bool=True, function_name: str|None=None) -> str: ...
    def autoFit(self) -> bool: ...
    def comment(self) -> str: ...
    def destroy(self, destroy_contents: bool) -> None: ...
    def fitAroundContents(self) -> None: ...
    def isMinimized(self) -> bool: ...
    def items(self) -> tuple[NetworkMovableItem, ...]: ...
    def minimizedSize(self) -> 'Vector2': ...
    def nodes(self, recurse: bool=True) -> tuple['Node', ...]: ...
    def networkBoxes(self, recurse: bool=True) -> tuple['NetworkBox', ...]: ...
    def removeAllItems(self) -> None: ...
    def removeItem(self, item: NetworkMovableItem) -> None: ...
    def resize(self, vector2: Vector2) -> None: ...
    def restoredSize(self) -> 'Vector2': ...
    def setAutoFit(self, on: bool) -> None: ...
    def setBounds(self, bounds: BoundingRect) -> None: ...
    def setComment(self, comment: str) -> None: ...
    def setMinimized(self, on: bool) -> None: ...
    def setAlpha(self, alpha: float) -> None: ...
    def setSize(self, size: '_Floats2') -> None: ...
    def stickyNotes(self, recurse: bool=True) -> tuple['StickyNote', ...]: ...


class StickyNote(NetworkMovableItem):
    """A sticky note in the network editor."""
    def text(self) -> str: ...
    def setText(self, text: str) -> None: ...
    def textColor(self) -> 'Color': ...
    def setColor(self, color: 'Color') -> None: ...
    def textSize(self) -> float: ...
    def setTextSize(self, size: float) -> None: ...
    def destroy(self) -> None: ...
    def drawBackground(self) -> bool: ...
    def isMinimized(self) -> bool: ...
    def maximizedSize(self) -> 'Vector2': ...
    def resize(self, vector2: _Floats2) -> None: ...
    def restoredSize(self) -> 'Vector2': ...
    def setBounds(self, bounds: BoundingRect) -> None: ...
    def setMinimized(self, on: bool) -> None: ...
    def setDrawBackground(self, on: bool) -> None: ...
    def asData(self) -> dict[str, Any]: ...
    def setFromData(self, data: dict[str, Any]) -> None: ...

class IndirectInput(NetworkMovableItem):
    """A subnet indirect input in the network editor."""
    # Inputs and Outputs
    def outputs(self) -> tuple['Node', ...]: ...
    def connections(self) -> tuple['NodeConnection', ...]: ...
    def input(self) -> 'Node|None': ...
    def inputOutputIndex(self) -> int: ...

    # Metadata
    def setColorDefault(self) -> None: ...
    def setSymbolicColorName(self, name: str) -> None: ...
    def setUseColorFromOutput(self, use_output_color: bool) -> None: ...
    def symbolicColorName(self) -> str: ...
    def useColorFromOutput(self) -> bool: ...


class NetworkDot(IndirectInput):
    """A network dot in the network editor."""
    def setPinned(self) -> bool: ...
    def isPinned(self) -> bool: ...
    @overload
    def setInput(self, node: 'Node|None', output_index: int = 0) -> None: ...
    @overload
    def setInput(self, input_index: int, node: 'Node|None', output_index: int = 0) -> None: ...
    def setInput(*args, **kwargs) -> None: ...
    def insertInput(self, input_index: int, node: 'Node|None', output_index: int = 0) -> None: ...
    def inputConnections(self) -> tuple['NodeConnection', ...]: ...
    def destroy(self) -> None: ...

    # As Data
    def asData(self) -> dict[str, Any]: ...
    def setFromData(self, data: dict[str, Any]) -> None: ...


class Node(NetworkMovableItem):
    """
    Houdini node object.

    Note: This class handles the complex type patterns in Houdini's C++ bindings
    where methods can return None unexpectedly and parameters accept multiple types.
    """
    def __init__(self) -> None: ...

    # Basic node info - these are generally reliable
    def type(self) -> 'NodeType': ...  # Can raise OperationFailed if node is invalid
    def children(self) -> tuple['Node', ...]: ...  # Empty tuple if no children
    
    # Hierarchy methods
    def nodes(self, node_path_tuple: tuple[str, ...]) -> tuple['Node|None', ...]: ...
    def item(self, item_path: str) -> 'NetworkMovableItem|None': ...
    def items(self, item_path_tuple: tuple[str, ...]) -> tuple['NetworkMovableItem|None', ...]: ...
    def isNetwork(self) -> bool: ...
    def isEditable(self) -> bool: ...
    def allItems(self) -> tuple['NetworkMovableItem', ...]: ...
    def allNodes(self) -> Iterator['Node']: ...
    def recursiveGlob(self, pattern: str, filter: 'EnumValue' = ..., include_subnets: bool = True) -> tuple['Node', ...]: ...

    # Node connections - handle Houdini's sparse input patterns
    def inputs(self) -> tuple['Node|None', ...]: ...  # None for unconnected inputs
    def inputsFollowingOutputs(self) -> tuple['Node', ...]: ...
    def input(self, inputidx: int) -> 'Node|None': ...
    def inputFollowingOutputs(self, inputidx: int) -> 'Node|None': ...
    def outputs(self) -> tuple['Node', ...]: ...  # Connected outputs only
    def setInput(self, input_index: int, node: 'Node|None', output_index: int = 0) -> None: ...
    def inputConnections(self) -> tuple['NodeConnection', ...]: ...  # Only connected inputs
    def outputConnections(self) -> tuple['NodeConnection', ...]: ...  # All output connections
    def inputConnectors(self) -> tuple[tuple['NodeConnection', ...], ...]: ...
    def outputConnectors(self) -> tuple[tuple['NodeConnection', ...], ...]: ...
    
    # Extended input/output methods
    def indirectInputs(self) -> tuple['SubnetIndirectInput', ...]: ...
    def subnetOutputs(self) -> tuple['Node', ...]: ...
    def inputAncestors(self, include_ref_inputs: bool = True, follow_subnets: bool = False, only_used_inputs: bool = False) -> tuple['Node', ...]: ...
    def setNamedInput(self, input_name: str, item_to_become_input: 'Node|None', output_name_or_index: str|int) -> None: ...
    def setFirstInput(self, item_to_become_input: 'Node|None', output_index: int = 0) -> None: ...
    def setNextInput(self, item_to_become_input: 'Node|None', output_index: int = 0, unordered_only: bool = False) -> None: ...
    def insertInput(self, input_index: int, item_to_become_input: 'Node|None', output_index: int = 0) -> None: ...
    def numOrderedInputs(self) -> int: ...
    def createInputNode(self, input_index: int, node_type_name: str, node_name: str|None = None, run_init_scripts: bool = True, load_contents: bool = True, exact_type_name: bool = False) -> 'Node': ...
    def createOutputNode(self, node_type_name: str, node_name: str|None = None, run_init_scripts: bool = True, load_contents: bool = True, exact_type_name: bool = False) -> 'Node': ...
    def inputNames(self) -> tuple[str, ...]: ...
    def inputLabels(self) -> tuple[str, ...]: ...
    def outputNames(self) -> tuple[str, ...]: ...
    def outputLabels(self) -> tuple[str, ...]: ...
    def editableInputStrings(self, input_index: int) -> dict[str, str]: ...
    def editableInputString(self, input_index: int, key: str) -> str: ...
    def setEditableInputString(self, input_index: int, key: str, value: str) -> None: ...

    # Input/output info
    def inputIndex(self, node: 'Node') -> int: ...  # -1 if not connected
    def outputIndex(self, node: 'Node') -> int: ...  # -1 if not connected
    def createNode(self, node_type: str, name: str|None = None) -> 'Node': ...  # Can raise OperationFailed
    def node(self, path: str) -> 'Node|None': ...  # None if path doesn't exist
    def glob(self, pattern: str) -> tuple['Node', ...]: ...  # Empty if no matches
    def destroy(self) -> None: ...  # Can raise OperationFailed if locked/referenced
    
    # Adding and removing methods
    def copyItems(self, items: tuple['NetworkMovableItem', ...], channel_reference_originals: bool = False, relative_references: bool = True, connect_outputs_to_multi_inputs: bool = True) -> tuple['NetworkMovableItem', ...]: ...
    def deleteItems(self, items: tuple['NetworkMovableItem', ...], disable_safety_checks: bool = False) -> None: ...
    
    # Assets methods
    def canCreateDigitalAsset(self) -> bool: ...

    def allSubChildren(self,
                      filter_type: str|None = None,
                      recurse_in_locked: bool = False) -> tuple['Node', ...]: ...
    
    # Selection methods
    def isCurrent(self) -> bool: ...
    def setCurrent(self, on: bool, clear_all_selected: bool = False) -> None: ...
    def selectedChildren(self, include_hidden: bool = False, include_hidden_support_nodes: bool = False) -> tuple['Node', ...]: ...
    def selectedItems(self, include_hidden: bool = False, include_hidden_support_nodes: bool = False) -> tuple['NetworkMovableItem', ...]: ...
    def numItems(self, item_type: 'EnumValue|None' = None, selected_only: bool = False, include_hidden: bool = False) -> int: ...

    # Node context helpers
    def childTypeCategory(self) -> 'NodeTypeCategory': ...
    
    # Subnet methods
    def isSubNetwork(self) -> bool: ...
    def collapseIntoSubnet(self, child_nodes: tuple['Node', ...], subnet_name: str|None = None, subnet_type: str|None = None) -> 'Node': ...
    def extractAndDelete(self) -> tuple['NetworkMovableItem', ...]: ...

    # Layout
    def moveToGoodPosition(self, relative_to_inputs: bool=True, move_inputs: bool=True, move_outputs: bool=True, move_unconnected: bool=True) -> 'Vector2': ...
    def layoutChildren(self, items: tuple['NetworkMovableItem', ...]=(), horizontal_spacing=-1.0, vertical_spacing=-1.0) -> 'Vector2': ...
    def isHidden(self) -> bool: ...
    def hide(self, hidden: bool) -> None: ...

    # Metadata methods
    def comment(self) -> str: ...
    def setComment(self, comment: str) -> None: ...
    def appendComment(self, comment: str) -> None: ...
    def isDisplayDescriptiveNameFlagSet(self) -> bool: ...
    def setDisplayDescriptiveNameFlag(self, on: bool) -> None: ...
    def creator(self) -> 'Node': ...
    def network(self) -> 'Node': ...
    
    # Cooking and error handling
    def errors(self) -> tuple[str, ...]: ...
    def warnings(self) -> tuple[str, ...]: ...
    def messages(self) -> tuple[str, ...]: ...

    # NetworkBox Management
    def networkBoxes(self) -> tuple['NetworkBox', ...]: ...
    def iterNetworkBoxes(self) -> Iterator['NetworkBox']: ...
    def findNetworkBox(self, name: str) -> 'NetworkBox|None': ...
    def findNetworkBoxes(self, pattern: str) -> tuple['NetworkBox', ...]: ...
    def createNetworkBox(self, name: str|None=None) -> 'NetworkBox': ...
    def copyNetworkBox(self, network_box_to_copy: 'NetworkBox', new_name: str|None=None, channel_reference_original: bool=False) -> 'NetworkBox': ...

    # StickyNote Management
    def stickyNotes(self) -> tuple['StickyNote', ...]: ...
    def iterStickyNotes(self) -> Iterator['StickyNote']: ...
    def findStickyNote(self, name: str) -> 'StickyNote|None': ...
    def findStickyNotes(self, pattern: str) -> tuple['StickyNote', ...]: ...
    def createStickyNote(self, name: str|None=None) -> 'StickyNote': ...
    def copyStickyNote(self, sticky_note_to_copy: 'StickyNote', new_name: str|None=None) -> 'StickyNote': ...

    # Network Dots
    def networkDots(self) -> tuple['NetworkDot', ...]: ...
    def createNetworkDot(self) -> 'NetworkDot': ...
    
    # Serialization methods
    def copyItemsToClipboard(self, items: tuple['NetworkMovableItem', ...]) -> None: ...
    def pasteItemsFromClipboard(self, position: 'Vector2|None' = None) -> None: ...
    
    # Operators
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    
    # User data methods
    def setUserData(self, name: str, value: str) -> None: ...
    def userDataDict(self) -> dict[str, str]: ...
    def userData(self, name: str) -> str|None: ...
    def destroyUserData(self, name: str, must_exist: bool = True) -> None: ...
    def clearUserDataDict(self) -> None: ...
    
    # Flag methods
    def isFlagReadable(self, flag: 'EnumValue') -> bool: ...
    def isFlagWritable(self, flag: 'EnumValue') -> bool: ...
    def isGenericFlagSet(self, flag: 'EnumValue') -> bool: ...
    def setGenericFlag(self, flag: 'EnumValue', value: bool) -> None: ...

class OpNode(Node):
    """A Houdini operator node."""
    # Adding and Removing
    def createOrMoveVisualizer(self, output_index: int) -> 'Node': ...
    def copyTo(self, destination_node: 'Node') -> 'Node': ...
    def reorderChild(self, src: int, dest: int) -> None: ...

    # parameters
    def param(self, param_path: str) -> 'Parm|None': ...
    def globParms(self, pattern: str, ignore_case: bool=False, search_label: bool=False, single_pattern: bool=False) -> tuple['Parm', ...]: ...
    def evalParm(self, parm_path: str) -> ParameterValue: ...
    def parms(self) -> tuple['Parm', ...]: ...
    def parmsReferencingThis(self) -> tuple['Parm', ...]: ...
    def allParms(self) -> Iterator['Parm']: ...
    def setParms(self, parm_dict: dict[str, Any]) -> None: ...
    def setParmsPending(self, parm_dict: dict[str, Any]) -> None: ...
    def setParmExpressions(self, parm_dict: dict[str, str], language: exprLanguage) -> None: ...
    def parmTuple(self, param_path: str) -> 'ParmTuple|None': ...
    def evalParmTuple(self, parm_path: str) -> tuple[ParameterValue, ...]: ...
    def parmTuples(self) -> tuple['ParmTuple', ...]: ...
    def parmsInFolder(self, folder_names: Sequence[str]) -> tuple['Parm', ...]: ...
    def parmTuplesInFolder(self, folder_names: Sequence[str]) -> tuple['ParmTuple', ...]: ...
    def expressionLanguage(self) -> exprLanguage: ...
    def setExpressionLanguage(self, language: exprLanguage) -> None: ...
    def parmAliases(self, recurse: bool=False) -> dict[str, str]: ...
    def clearParmAliases(self) -> None: ...
    def spareParms(self) -> tuple['Parm', ...]: ...
    def removeSpareParms(self) -> None: ...
    def parmTemplateGroup(self) -> 'ParmTemplateGroup': ...
    def setParmTemplateGroup(self, parm_template_group: 'ParmTemplateGroup', rename_conflicting_parms: bool=False) -> None: ...
    # Deprecated methods for spare parm tuples - these are not recommended for use in new code
    #def addSpareParmTuple(self, parm_template: 'ParmTemplate', in_folder: Sequence[str]=(), create_missing_folders: bool=False) -> 'ParmTuple': ...
    #def removeSpareParmTuple(self, parm_name: str) -> None: ...
    def addControlParmFolder(self, folder_name: str|None=None, parm_name: str|None=None) -> None: ...
    #def addSpareParmFolder(self, folder_name: str|None=None, parm_name: str|None=None, create_missing_folders: bool=False) -> 'ParmTuple': ...
    def removeSpareParmFolder(self, folder_name: Sequence[str]) -> None: ...
    def replaceSpareParmFolder(self, parm_tuple_name: str, parm_template : ParmTemplate) -> None: ...
    def localVariables(self) -> tuple[str, ...]: ...
    def localAttributes(self) -> tuple[str, ...]: ...
    def saveParmClip(self, file_name: str, start: int|None=None, end: int|None=None, sample_rate: int=0, scoped_only: bool=False) -> None: ...
    def loadParmClip(self, file_name: str, sample_rate: int=0, start: int|None=None) -> None: ...
    def parmClipData(self, start=None, end=None, binary=True, use_blosc_compression=True, sample_rate=0, scoped_only=False) -> bytes: ...
    def setParmClipData(self, data: bytes, binary: bool=True, blosc_compressed: bool=True, sample_rate: int=0, start: int=1) -> None: ...

    # Dependencies
    def references(self, include_children: bool=True) -> tuple['Node', ...]: ...
    def dependents(self, include_children: bool=True) -> tuple['Node', ...]: ...
    def fileReferences(self, recurse: bool=True, project_dir_variable: str="HIP", include_all_refs: bool=True) -> tuple[tuple[Parm, str], ...]: ...

    # Assets
    def createDigitalAsset(self, name: str|None=None, hda_file_name: str|None=None, description: str|None=None, min_num_inputs: int=0, max_num_inputs: int=0, compress_content: bool=False, comment: str|None=None, version: str|None=None, save_as_embedded: bool=False, ignore_external_references: bool=False, change_node_type: bool=True, create_backup: bool=True, install_path: str|None=None) -> 'Node': ...
    def createCompiledDigitalAsset(self, name: str|None=None, hda_file_name: str|None=None, description: str|None=None) -> None: ...
    def changeNodeType(self, new_node_type: str, keep_name: bool=True, keep_parms: bool=True, keep_network_contents: bool=True, force_change_on_node_type_match: bool=False) -> None: ...
    def allowEditingOfContents(self, propagate: bool=False) -> None: ...
    def matchCurrentDefinition(self) -> None: ...
    def syncDelayedDefinition(self) -> None: ...
    def isDelayedDefinition(self) -> bool: ...
    def isLockedHDA(self) -> bool: ...
    def isInsideLockedHDA(self) -> bool: ...
    def isEditableInsideLockedHDA(self) -> bool: ...
    def isMaterialManager(self) -> bool: ...
    def hdaModule(self) -> 'HDAModule': ...
    def hm(self) -> 'HDAModule': ...
    def hdaViewerStateModule(self) -> 'HDAViewerStateModule': ...
    def hdaViewerHandleModule(self) -> 'HDAViewerHandleModule': ...
    def syncNodeVersionIfNeeded(self, from_version: str) -> None: ...


class HDAModule(types.ModuleType):
    "User HDA module for custom Python code in digital assets."
    pass

class HDAViewerStateModule(types.ModuleType):
    "User HDA viewer state module for custom Python code in digital assets."
    pass

class HDAViewerHandleModule(types.ModuleType):
    "User HDA viewer handle module for custom Python code in digital assets."
    pass

class Parm:
    """Houdini parameter object."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def eval(self) -> Any: ...
    def evalAsFloat(self) -> float: ...
    def evalAsInt(self) -> int: ...
    def evalAsString(self) -> str: ...
    def set(self, value: Any) -> None: ...
    def setExpression(self, expression: str) -> None: ...
    def expression(self) -> str: ...
    def unexpandedString(self) -> str: ...
    def node(self) -> 'Node': ...
    def parmTemplate(self) -> 'ParmTemplate': ...
    def isLocked(self) -> bool: ...
    def lock(self, on: bool) -> None: ...

class ParmTuple:
    """Houdini parameter tuple object (for vector parameters)."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def eval(self) -> tuple[float, ...]: ...
    def evalAsFloats(self) -> tuple[float, ...]: ...
    def evalAsInts(self) -> tuple[int, ...]: ...
    def evalAsStrings(self) -> tuple[str, ...]: ...
    def set(self, values: Sequence[Any]) -> None: ...
    def setExpression(self, expressions: Sequence[str]) -> None: ...
    def node(self) -> 'Node': ...
    def parmTemplate(self) -> 'ParmTemplate': ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> 'Parm': ...

class NodeConnection:
    """Houdini node connection object."""
    def __init__(self) -> None: ...
    def inputNode(self) -> 'Node': ...
    def outputNode(self) -> 'Node': ...
    def inputIndex(self) -> int: ...
    def outputIndex(self) -> int: ...

class NodeType:
    """Houdini node type object."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def description(self) -> str: ...
    def helpUrl(self) -> str: ...
    def category(self) -> 'NodeTypeCategory': ...
    def defaultName(self) -> str: ...
    def maxNumInputs(self) -> int: ...
    def minNumInputs(self) -> int: ...
    def maxNumOutputs(self) -> int: ...
    def childTypeCategory(self) -> 'NodeTypeCategory': ...
    def isGenerator(self) -> bool: ...
    def isManager(self) -> bool: ...
    def embeddedHelp(self) -> str: ...
    def defaultColor(self) -> 'Color': ...
    def setDefaultColor(self, color: 'Color') -> None: ...
    def defaultShape(self) -> str: ...
    def setDefaultShape(self, shape: str) -> None: ...
    def isWritable(self) -> bool: ...
    def isReadOnly(self) -> bool: ...
    def icon(self) -> str: ...
    def resolvedIcon(self) -> str: ...
    def hasUnorderedInputs(self) -> bool: ...
    def hasEditableInputData(self) -> bool: ...
    def parmTemplates(self) -> tuple['ParmTemplate', ...]: ...
    def parmTemplateGroup(self) -> 'ParmTemplateGroup': ...
    def deprecationInfo(self) -> dict[str, Any]: ...

class ParmTemplateGroup:
    """Houdini parameter template group object."""
    def __init__(self, parm_templates: Sequence[ParmTemplate]=()) -> None: ...
    def name(self) -> str: ...
    def label(self) -> str: ...
    def setName(self, name: str) -> None: ...
    def setLabel(self, label: str) -> None: ...
    def clear(self) -> None: ...
    def entries(self) -> tuple['ParmTemplate', ...]: ...
    def parmTemplates(self) -> tuple['ParmTemplate', ...]: ...
    def find(self, name: str) -> 'ParmTemplate|None': ...
    def findFolder(self, label_or_labels: str | Sequence[str]) -> 'ParmTemplateGroup|None': ...
    def findIndices(self, label_or_labels: str | Sequence[str]) -> int | tuple[int, ...]: ...
    def entryAtIndices(self, indices: int | Sequence[int]) -> 'ParmTemplate': ...
    def asCode(self, function_name: str | None=None, variable_name: str | None=None) -> str: ...
    # Additional methods for adding and removing parms

class NodeTypeCategory:
    """Houdini node type category object."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def description(self) -> str: ...
    def nodeTypes(self) -> dict[str, 'NodeType']: ...
    def nodeType(self, name: str) -> 'NodeType|None': ...
    def label(self) -> str: ...
    def allowedChildTypes(self) -> tuple['NodeType', ...]: ...
    def canContainNodeType(self, node_type: 'NodeType') -> bool: ...
    def hasSubNetworkType(self) -> bool: ...
    def subnetworkType(self) -> 'NodeType|None': ...
    def defaultColor(self) -> 'Color': ...


class Color:
    """Houdini color object."""
    def __init__(self, rgb: tuple) -> None: ...
    def rgb(self) -> tuple[float, float, float]: ...
    def setRgb(self, rgb: tuple[float, float, float]) -> None: ...
    def hsv(self) -> tuple[float, float, float]: ...
    def setHsv(self, hsv: tuple[float, float, float]) -> None: ...
    def hsl(self) -> tuple[float, float, float]: ...
    def setHsl(self, hsl: tuple[float, float, float]) -> None: ...
    def lab(self) -> tuple[float, float, float]: ...
    def setLAB(self, lab: tuple[float, float, float]) -> None: ...
    def tmi(self) -> tuple[float, float, float]: ...
    def setTmi(self, tmi: tuple[float, float, float]) -> None: ...
    def xyz(self) -> tuple[float, float, float]: ...
    def setXYZ(self, xyz: tuple[float, float, float]) -> None: ...
    def ocio_transform(self, from_space: str, to_space: str, looks: str) -> 'Color': ...
    def ocio_viewTransform(self, src_colorspace, display_name, view_name) -> 'Color': ...
    @staticmethod
    def reload_ocio() -> None: ...
    @staticmethod
    def ocio_spaces() -> tuple[str, ...]: ...
    @staticmethod
    def ocio_configPath() -> str: ...
    @staticmethod
    def ocio_activeDisplays() -> tuple[str, ...]: ...
    @staticmethod
    def ocio_activeViews() -> tuple[str, ...]: ...
    @staticmethod
    def ocio_looks() -> tuple[str, ...]: ...
    @staticmethod
    def ocio_roles() -> tuple[str, ...]: ...
    @staticmethod
    def ocio_views() -> tuple[str, ...]: ...
    @staticmethod
    def ocio_DefaultView() -> str: ...
    @staticmethod
    def ocio_DefaultDisplay() -> str: ...

class ParmTemplate:
    """Houdini parameter template object."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def label(self) -> str: ...
    def type(self) -> 'parmTemplateType': ...
    def numComponents(self) -> int: ...
    def defaultValue(self) -> Any: ...
    def help(self) -> str: ...
    def tags(self) -> dict[str, str]: ...
    def setTags(self, tags: dict[str, str]) -> None: ...
    def scriptCallback(self) -> str: ...
    def setScriptCallback(self, callback: str) -> None: ...
    def scriptCallbackLanguage(self) -> str: ...
    def setScriptCallbackLanguage(self, language: str) -> None: ...

class SopNode(Node):
    """
    Houdini geometry (SOP) node.
    Handles geometry operations and cooking properly.
    """
    def geometry(self) -> 'Geometry': ...  # None if not cooked or failed
    def cook(self, force: bool = False) -> None: ...  # Can raise cooking errors
    def renderGeometry(self) -> 'Geometry': ...  # Rendered geometry
    def displayGeometry(self) -> 'Geometry': ...  # Display geometry

    # SOP-specific parameter access
    def geometryType(self) -> str: ...  # "polygon", "nurbs", etc.
    def isGeometryReadOnly(self) -> bool: ...

class ObjNode(Node):
    """
    Houdini object (OBJ) node.
    Handles transforms and object-level operations.
    """
    def worldTransform(self) -> 'Matrix4': ...  # Can be expensive, may fail
    def localTransform(self) -> 'Matrix4': ...  # Local transformation
    def worldTransformAtTime(self, time: float) -> 'Matrix4': ...
    def localTransformAtTime(self, time: float) -> 'Matrix4': ...

    # Object-specific operations
    def isDisplayFlagSet(self) -> bool: ...  # Override with OBJ-specific behavior
    def isSelectableFlagSet(self) -> bool: ...
    def setSelectableFlag(self, on: bool) -> None: ...

class ChopNode(Node):
    """Houdini channel operator (CHOP) node."""
    def tracks(self) -> tuple['Track', ...]: ...
    def track(self, name: str) -> 'Track|None': ...

class RopNode(Node):
    """Houdini render operator (ROP) node."""
    def render(self, frame_range: tuple[int, int]|None = None,
               background: bool = False) -> None: ...  # Can take a long timeclass VopNode(Node):
    """Houdini VEX operator (VOP) node."""
    def vexCode(self) -> str: ...  # Generated VEX code
    def shaderName(self) -> str: ...

class DopNode(Node):
    """Houdini dynamics operator (DOP) node."""
    def simulation(self) -> 'DopSimulation|None': ...

# Additional specialized node types
class CopNode(Node):
    """Houdini compositing operator (COP) node."""
    def image(self) -> 'Image|None': ...

class TopNode(Node):
    """Houdini task operator (TOP/PDG) node."""
    def workItems(self) -> tuple['WorkItem', ...]: ...

class Geometry:
    """Houdini geometry object."""
    def __init__(self) -> None: ...
    def points(self) -> tuple['Point', ...]: ...
    def prims(self) -> tuple['Prim', ...]: ...
    def vertices(self) -> tuple['Vertex', ...]: ...
    def numPoints(self) -> int: ...
    def numPrims(self) -> int: ...

class Point:
    """Houdini geometry point."""
    def __init__(self) -> None: ...
    def number(self) -> int: ...
    def position(self) -> 'Vector3': ...
    def setPosition(self, pos: 'Vector3') -> None: ...

class Prim:
    """Houdini geometry primitive."""
    def __init__(self) -> None: ...
    def number(self) -> int: ...
    def vertices(self) -> tuple['Vertex', ...]: ...

class Vertex:
    """Houdini geometry vertex."""
    def __init__(self) -> None: ...
    def number(self) -> int: ...
    def point(self) -> 'Point': ...

class Vector2:
    """2D vector."""
    def __init__(self, x: float = 0, y: float = 0) -> None: ...
    def x(self) -> float: ...
    def y(self) -> float: ...

class Vector3:
    """3D vector."""
    def __init__(self, x: float = 0, y: float = 0, z: float = 0) -> None: ...
    def x(self) -> float: ...
    def y(self) -> float: ...
    def z(self) -> float: ...

class Matrix4:
    """4x4 transformation matrix."""
    def __init__(self) -> None: ...

# Module-level functions - these are the PRIMARY module interface
# Note: These handle the static/instance confusion by being clearly module-level

def node(path: str) -> Node:
    """
    Get node by path. Returns None if path doesn't exist.
    This is the main way to access existing nodes.
    """
    ...

def root() -> Node:
    """Get root node. Always succeeds."""
    ...

def pwd() -> Node:
    """Get current working directory node. Always succeeds."""
    ...

def cd(path: str) -> None:
    """
    Change current directory. Can raise OperationFailed if path invalid.
    Affects behavior of relative paths in other hou functions.
    """
    ...

def selectedNodes() -> tuple[Node, ...]:
    """Get currently selected nodes. Empty tuple if none selected."""
    ...

def clearAllSelected() -> None:
    """Clear all node selections. Always succeeds."""
    ...

# Enhanced node finding with better error handling
def findNode(path: str) -> Node:
    """Find node by path, returns None if not found (alias for node())."""
    ...

def nodeAtPath(path: str, create_missing_dirs: bool = False) -> Node:
    """
    Get node at path, optionally creating parent directories.
    More robust than basic node() function.
    """
    ...

# Node type functions
def nodeTypeCategories() -> dict[str, NodeTypeCategory]:
    """Get all node type categories."""
    ...

def nodeType(category: str | NodeTypeCategory, name: str) -> NodeType|None:
    """Get a specific node type."""
    ...

# Session info
def applicationName() -> str:
    """Get application name."""
    ...

def applicationVersion() -> tuple[int, int, int]:
    """Get application version as tuple."""
    ...

def applicationVersionString() -> str:
    """Get application version as string."""
    ...

def isUIAvailable() -> bool:
    """Check if UI is available."""
    ...

class HipFile:
    """Houdini hip file operations."""
    def name(self) -> str: ...
    def path(self) -> str: ...
    def save(self, file_name: str|None = None) -> None: ...
    def load(self, file_name: str) -> None: ...
    def clear(self) -> None: ...
    def isNewFile(self) -> bool: ...

# File operations - hipFile is both a function and an instance in Houdini
hipFile: HipFile

# Common exceptions that Houdini can raise
class OperationFailed(Exception):
    """Houdini operation failed exception."""
    pass

class InvalidInput(Exception):
    """Invalid input exception."""
    pass

class LoadWarning(Warning):
    """Houdini load warning."""
    pass

# Additional specialized classes for different node types
class Track:
    """CHOP track (channel) object."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def samples(self) -> tuple[float, ...]: ...
    def values(self) -> tuple[float, ...]: ...

class DopSimulation:
    """DOP simulation object."""
    def __init__(self) -> None: ...
    def objects(self) -> tuple['DopObject', ...]: ...
    def timestep(self) -> float: ...

class DopObject:
    """DOP simulation object."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def geometry(self) -> 'Geometry|None': ...

class Image:
    """COP image object."""
    def __init__(self) -> None: ...
    def resolution(self) -> tuple[int, int]: ...
    def pixels(self) -> Any: ...  # NumPy array if available

class WorkItem:
    """TOP/PDG work item."""
    def __init__(self) -> None: ...
    def name(self) -> str: ...
    def state(self) -> str: ...  # "ready", "cooking", "cooked", "failed"

# Context managers for safer Houdini operations
class UndoGroup:
    """Context manager for grouping operations into a single undo."""
    def __init__(self, name: str) -> None: ...
    def __enter__(self) -> 'UndoGroup': ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...

def undos() -> 'UndoManager':
    """Get undo manager for grouping operations."""
    ...

class UndoManager:
    """Undo manager for grouping operations."""
    def group(self, name: str) -> UndoGroup: ...
    def clear(self) -> None: ...
    def disabler(self) -> 'UndoDisabler': ...

class UndoDisabler:
    """Context manager to disable undo tracking."""
    def __enter__(self) -> 'UndoDisabler': ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...

# Progress reporting for long operations
def progressBar() -> 'ProgressBar':
    """Get progress bar for long operations."""
    ...

class ProgressBar:
    """Progress reporting for long operations."""
    def __init__(self) -> None: ...
    def __enter__(self) -> 'ProgressBar': ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
    def update(self, progress: float, message: str = "") -> None: ...
    def setLabel(self, label: str) -> None: ...
